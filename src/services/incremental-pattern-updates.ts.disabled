/**
 * Incremental Pattern Updates Service
 * 
 * Efficiently updates pattern discovery when new experiences are added,
 * avoiding expensive full re-computation on every change.
 */

import { SourceRecord } from '../core/types.js';
import { PatternCluster, ExperientialResonance, PatternDiscoveryService } from './pattern-discovery.js';
import { NavigablePattern, PatternCache } from './pattern-manager.js';

// ============================================================================
// INTERFACES
// ============================================================================

export interface PatternUpdate {
  type: 'add' | 'modify' | 'remove' | 'merge' | 'split';
  patternId: string;
  affectedExperiences: string[];
  confidence: number;
  timestamp: Date;
}

export interface IncrementalResult {
  updatedPatterns: NavigablePattern[];
  newPatterns: NavigablePattern[];
  removedPatterns: string[];
  updates: PatternUpdate[];
  performance: {
    experiencesProcessed: number;
    patternsUpdated: number;
    duration: number;
    efficiency: number; // 0-1, where 1 = no full recomputation needed
  };
}

// ============================================================================
// INCREMENTAL PATTERN UPDATE SERVICE
// ============================================================================

export class IncrementalPatternUpdateService {
  private discoveryService: PatternDiscoveryService;
  private readonly SIMILARITY_THRESHOLD = 0.7;
  private readonly CONFIDENCE_THRESHOLD = 0.3;
  private readonly MERGE_THRESHOLD = 0.8;
  
  constructor(discoveryService: PatternDiscoveryService) {
    this.discoveryService = discoveryService;
  }
  
  /**
   * Process new or updated experiences incrementally
   */
  async processExperiences(
    newExperiences: SourceRecord[],
    existingCache: PatternCache
  ): Promise<IncrementalResult> {
    const startTime = Date.now();
    const updates: PatternUpdate[] = [];
    const updatedPatterns: NavigablePattern[] = [...existingCache.patterns];
    const newPatterns: NavigablePattern[] = [];
    const removedPatterns: string[] = [];
    
    // Extract resonances for new experiences
    const newResonances = await Promise.all(
      newExperiences.map(exp => this.discoveryService.extractResonance(exp))
    );
    
    // For each new experience, determine pattern assignment
    for (const resonance of newResonances) {
      const assignment = await this.assignExperienceToPatterns(
        resonance,
        updatedPatterns,
        existingCache
      );
      
      if (assignment.type === 'existing') {
        // Add to existing pattern(s)
        await this.addToExistingPattern(
          resonance,
          assignment.patternIds,
          updatedPatterns,
          updates
        );
      } else if (assignment.type === 'new') {
        // Create new pattern
        const newPattern = await this.createNewPattern(
          [resonance],
          updatedPatterns.length,
          existingCache
        );
        if (newPattern) {
          newPatterns.push(newPattern);
          updates.push({
            type: 'add',
            patternId: newPattern.id,
            affectedExperiences: [resonance.source.id],
            confidence: newPattern.coherence,
            timestamp: new Date()
          });
        }
      } else if (assignment.type === 'merge') {
        // Merge patterns
        await this.mergePatterns(
          assignment.patternIds,
          resonance,
          updatedPatterns,
          removedPatterns,
          updates
        );
      }
    }
    
    // Check for pattern evolution and quality changes
    await this.evaluatePatternEvolution(updatedPatterns, updates);
    
    // Calculate performance metrics
    const duration = Date.now() - startTime;
    const efficiency = this.calculateEfficiency(newExperiences.length, existingCache.patterns.length);
    
    return {
      updatedPatterns: updatedPatterns.filter(p => !removedPatterns.includes(p.id)),
      newPatterns,
      removedPatterns,
      updates,
      performance: {
        experiencesProcessed: newExperiences.length,
        patternsUpdated: updates.length,
        duration,
        efficiency
      }
    };
  }
  
  /**
   * Determine how to assign a new experience to patterns
   */
  private async assignExperienceToPatterns(
    resonance: ExperientialResonance,
    existingPatterns: NavigablePattern[],
    cache: PatternCache
  ): Promise<{
    type: 'existing' | 'new' | 'merge';
    patternIds: string[];
    confidence: number;
  }> {
    const similarities: Array<{ patternId: string; similarity: number }> = [];
    
    // Calculate similarity to each existing pattern
    for (const pattern of existingPatterns) {
      const similarity = await this.calculatePatternSimilarity(resonance, pattern, cache);
      if (similarity > this.SIMILARITY_THRESHOLD) {
        similarities.push({ patternId: pattern.id, similarity });
      }
    }
    
    // Sort by similarity
    similarities.sort((a, b) => b.similarity - a.similarity);
    
    if (similarities.length === 0) {
      // No similar patterns - create new
      return { type: 'new', patternIds: [], confidence: 0 };
    } else if (similarities.length === 1) {
      // One similar pattern - add to existing
      return { 
        type: 'existing', 
        patternIds: [similarities[0].patternId], 
        confidence: similarities[0].similarity 
      };
    } else if (similarities.length > 1 && similarities[0].similarity > this.MERGE_THRESHOLD) {
      // Multiple high-similarity patterns - consider merge
      const topSimilar = similarities.filter(s => s.similarity > this.MERGE_THRESHOLD);
      return { 
        type: 'merge', 
        patternIds: topSimilar.map(s => s.patternId), 
        confidence: topSimilar[0].similarity 
      };
    } else {
      // Add to most similar pattern
      return { 
        type: 'existing', 
        patternIds: [similarities[0].patternId], 
        confidence: similarities[0].similarity 
      };
    }
  }
  
  /**
   * Add experience to existing pattern(s)
   */
  private async addToExistingPattern(
    resonance: ExperientialResonance,
    patternIds: string[],
    patterns: NavigablePattern[],
    updates: PatternUpdate[]
  ): Promise<void> {
    for (const patternId of patternIds) {
      const pattern = patterns.find(p => p.id === patternId);
      if (!pattern) continue;
      
      // Add experience to pattern
      pattern.experienceIds.push(resonance.source.id);
      
      // Update pattern metadata
      await this.updatePatternMetadata(pattern, resonance);
      
      // Recalculate coherence
      const newCoherence = await this.recalculatePatternCoherence(pattern);
      pattern.coherence = newCoherence;
      
      updates.push({
        type: 'modify',
        patternId: pattern.id,
        affectedExperiences: [resonance.source.id],
        confidence: newCoherence,
        timestamp: new Date()
      });
    }
  }
  
  /**
   * Create new pattern from experiences
   */
  private async createNewPattern(
    resonances: ExperientialResonance[],
    existingPatternCount: number,
    cache: PatternCache
  ): Promise<NavigablePattern | null> {
    if (resonances.length === 0) return null;
    
    // Generate pattern metadata
    const experiences = resonances.map(r => r.source);
    const metadata = this.generatePatternMetadata(experiences);
    const name = this.generatePatternName(experiences, metadata.themes);
    
    // Calculate coherence
    const coherence = await this.calculateNewPatternCoherence(resonances);
    
    if (coherence < this.CONFIDENCE_THRESHOLD) {
      return null; // Pattern not coherent enough
    }
    
    return {
      id: `L1-P${existingPatternCount + 1}`,
      name,
      level: 1,
      experienceIds: experiences.map(e => e.id),
      coherence,
      children: [],
      metadata
    };
  }
  
  /**
   * Merge multiple patterns into one
   */
  private async mergePatterns(
    patternIds: string[],
    triggeringResonance: ExperientialResonance,
    patterns: NavigablePattern[],
    removedPatterns: string[],
    updates: PatternUpdate[]
  ): Promise<void> {
    if (patternIds.length < 2) return;
    
    // Find patterns to merge
    const toMerge = patterns.filter(p => patternIds.includes(p.id));
    if (toMerge.length < 2) return;
    
    // Create merged pattern
    const mergedExperienceIds = [
      ...new Set([
        ...toMerge.flatMap(p => p.experienceIds),
        triggeringResonance.source.id
      ])
    ];
    
    // Use the first pattern as base
    const basePattern = toMerge[0];
    basePattern.experienceIds = mergedExperienceIds;
    
    // Update metadata and coherence
    const allExperiences = await this.getExperiencesByIds(mergedExperienceIds);
    basePattern.metadata = this.generatePatternMetadata(allExperiences);
    basePattern.name = this.generatePatternName(allExperiences, basePattern.metadata.themes);
    basePattern.coherence = await this.calculateMergedPatternCoherence(allExperiences);
    
    // Remove other patterns
    for (let i = 1; i < toMerge.length; i++) {
      removedPatterns.push(toMerge[i].id);
      const index = patterns.findIndex(p => p.id === toMerge[i].id);
      if (index >= 0) {
        patterns.splice(index, 1);
      }
    }
    
    updates.push({
      type: 'merge',
      patternId: basePattern.id,
      affectedExperiences: mergedExperienceIds,
      confidence: basePattern.coherence,
      timestamp: new Date()
    });
  }
  
  /**
   * Evaluate if existing patterns need evolution or splitting
   */
  private async evaluatePatternEvolution(
    patterns: NavigablePattern[],
    updates: PatternUpdate[]
  ): Promise<void> {
    for (const pattern of patterns) {
      // Check if pattern has grown too large or incoherent
      if (pattern.experienceIds.length > 20) {
        await this.considerPatternSplit(pattern, patterns, updates);
      }
      
      // Check if pattern coherence has degraded
      if (pattern.coherence < this.CONFIDENCE_THRESHOLD) {
        await this.considerPatternRestructure(pattern, updates);
      }
    }
  }
  
  /**
   * Consider splitting a large pattern
   */
  private async considerPatternSplit(
    pattern: NavigablePattern,
    patterns: NavigablePattern[],
    updates: PatternUpdate[]
  ): Promise<void> {
    // For now, just log the consideration
    // TODO: Implement pattern splitting logic
    console.log(`Pattern ${pattern.id} with ${pattern.experienceIds.length} experiences may need splitting`);
  }
  
  /**
   * Consider restructuring a low-coherence pattern
   */
  private async considerPatternRestructure(
    pattern: NavigablePattern,
    updates: PatternUpdate[]
  ): Promise<void> {
    // For now, just log the consideration
    // TODO: Implement pattern restructuring logic
    console.log(`Pattern ${pattern.id} with coherence ${pattern.coherence} may need restructuring`);
  }
  
  // ============================================================================
  // UTILITY METHODS
  // ============================================================================
  
  /**
   * Calculate similarity between experience and existing pattern
   */
  private async calculatePatternSimilarity(
    resonance: ExperientialResonance,
    pattern: NavigablePattern,
    cache: PatternCache
  ): Promise<number> {
    // Get pattern's average resonance
    const patternExperiences = await this.getExperiencesByIds(pattern.experienceIds);
    const patternResonances = await Promise.all(
      patternExperiences.map(exp => this.discoveryService.extractResonance(exp))
    );
    
    // Calculate average similarity across all pattern members
    let totalSimilarity = 0;
    for (const patternResonance of patternResonances) {
      const similarity = this.calculateResonanceSimilarity(resonance, patternResonance);
      totalSimilarity += similarity;
    }
    
    return totalSimilarity / patternResonances.length;
  }
  
  /**
   * Calculate similarity between two resonances
   */
  private calculateResonanceSimilarity(
    r1: ExperientialResonance,
    r2: ExperientialResonance
  ): number {
    // Phenomenological similarity (30%)
    const phenoSim = this.cosineSimilarity(
      r1.phenomenological.vector,
      r2.phenomenological.vector
    ) * 0.3;
    
    // Linguistic similarity (50%)
    const lingualSim = this.cosineSimilarity(
      r1.linguistic.embedding,
      r2.linguistic.embedding
    ) * 0.5;
    
    // Temporal similarity (20%)
    const temporalSim = this.calculateTemporalSimilarity(
      r1.temporal,
      r2.temporal
    ) * 0.2;
    
    return phenoSim + lingualSim + temporalSim;
  }
  
  /**
   * Calculate temporal similarity between signatures
   */
  private calculateTemporalSimilarity(t1: any, t2: any): number {
    let similarity = 0;
    
    // Time of day similarity
    const timeDiff = Math.abs(t1.time_of_day - t2.time_of_day);
    similarity += (1 - timeDiff) * 0.4;
    
    // Day of week similarity
    const dayDiff = Math.abs(t1.day_of_week - t2.day_of_week);
    similarity += (1 - dayDiff / 6) * 0.3;
    
    // Processing immediacy similarity
    const processingSim = t1.processing_immediacy === t2.processing_immediacy ? 1 : 0;
    similarity += processingSim * 0.3;
    
    return Math.max(0, Math.min(1, similarity));
  }
  
  /**
   * Cosine similarity between vectors
   */
  private cosineSimilarity(a: number[], b: number[]): number {
    if (a.length !== b.length) return 0;
    
    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
    const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
    const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
    
    if (magnitudeA === 0 || magnitudeB === 0) return 0;
    return dotProduct / (magnitudeA * magnitudeB);
  }
  
  /**
   * Update pattern metadata with new experience
   */
  private async updatePatternMetadata(
    pattern: NavigablePattern,
    resonance: ExperientialResonance
  ): Promise<void> {
    // Add emoji if present
    const emoji = resonance.source.experience?.emoji;
    if (emoji && !pattern.metadata.emojis.includes(emoji)) {
      pattern.metadata.emojis.push(emoji);
      // Keep only top 4 emojis
      if (pattern.metadata.emojis.length > 4) {
        pattern.metadata.emojis = pattern.metadata.emojis.slice(0, 4);
      }
    }
    
    // Update themes
    const newText = (resonance.source.experience?.narrative || resonance.source.content || '').toLowerCase();
    const newThemes = this.extractThemes(newText);
    pattern.metadata.themes = [...new Set([...pattern.metadata.themes, ...newThemes])].slice(0, 10);
    
    // Update qualities
    const qualities = resonance.source.experience?.qualities || [];
    qualities.forEach(q => {
      const currentValue = pattern.metadata.qualities[q.type] || 0;
      const experienceCount = pattern.experienceIds.length;
      // Update running average
      pattern.metadata.qualities[q.type] = (currentValue * (experienceCount - 1) + q.prominence) / experienceCount;
    });
    
    // Update recency
    pattern.metadata.recency = this.calculateRecency([resonance.source]);
  }
  
  /**
   * Recalculate pattern coherence
   */
  private async recalculatePatternCoherence(pattern: NavigablePattern): Promise<number> {
    // Simple coherence based on size and quality spread
    const size = pattern.experienceIds.length;
    const sizeScore = Math.min(size / 5, 1); // Max at 5 experiences
    
    // Quality consistency
    const qualityValues = Object.values(pattern.metadata.qualities);
    const qualityMean = qualityValues.reduce((sum, val) => sum + val, 0) / qualityValues.length;
    const qualityVariance = qualityValues.reduce((sum, val) => sum + Math.pow(val - qualityMean, 2), 0) / qualityValues.length;
    const consistencyScore = 1 - Math.min(qualityVariance, 1);
    
    return (sizeScore + consistencyScore) / 2;
  }
  
  /**
   * Calculate coherence for new pattern
   */
  private async calculateNewPatternCoherence(resonances: ExperientialResonance[]): Promise<number> {
    if (resonances.length < 2) return 0.5;
    
    // Average pairwise similarity
    let totalSimilarity = 0;
    let pairCount = 0;
    
    for (let i = 0; i < resonances.length; i++) {
      for (let j = i + 1; j < resonances.length; j++) {
        totalSimilarity += this.calculateResonanceSimilarity(resonances[i], resonances[j]);
        pairCount++;
      }
    }
    
    return pairCount > 0 ? totalSimilarity / pairCount : 0;
  }
  
  /**
   * Calculate coherence for merged pattern
   */
  private async calculateMergedPatternCoherence(experiences: SourceRecord[]): Promise<number> {
    // Extract resonances and calculate coherence
    const resonances = await Promise.all(
      experiences.map(exp => this.discoveryService.extractResonance(exp))
    );
    return this.calculateNewPatternCoherence(resonances);
  }
  
  /**
   * Calculate efficiency of incremental update
   */
  private calculateEfficiency(newExperienceCount: number, existingPatternCount: number): number {
    // Efficiency = incremental work vs full recomputation work
    const incrementalWork = newExperienceCount * existingPatternCount; // O(n*m)
    const fullWork = Math.pow(existingPatternCount + newExperienceCount, 2); // O((n+m)^2)
    
    return Math.max(0, Math.min(1, 1 - (incrementalWork / fullWork)));
  }
  
  // ============================================================================
  // PLACEHOLDER METHODS (to be implemented)
  // ============================================================================
  
  private async getExperiencesByIds(ids: string[]): Promise<SourceRecord[]> {
    // TODO: Implement retrieval from storage
    return [];
  }
  
  private generatePatternMetadata(experiences: SourceRecord[]): NavigablePattern['metadata'] {
    // TODO: Implement metadata generation
    return {
      emojis: [],
      themes: [],
      qualities: {},
      recency: 'active'
    };
  }
  
  private generatePatternName(experiences: SourceRecord[], themes: string[]): string {
    // TODO: Implement name generation
    return 'New Pattern';
  }
  
  private extractThemes(text: string): string[] {
    // TODO: Implement theme extraction
    return [];
  }
  
  private calculateRecency(experiences: SourceRecord[]): 'active' | 'recent' | 'past' | 'dormant' {
    // TODO: Implement recency calculation
    return 'active';
  }
}